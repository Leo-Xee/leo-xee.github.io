{"componentChunkName":"component---src-templates-blog-post-js","path":"/React/why-state-management/","result":{"data":{"site":{"siteMetadata":{"title":"leo-xee.io","author":"Leo-Xee","siteUrl":"https://leo-xee.github.io","comment":{"disqusShortName":"","utterances":"leo-xee/blog-comments"},"sponsor":{"buyMeACoffeeId":"leoxexe"}}},"markdownRemark":{"id":"ebfb21e8-0944-51a0-a9e5-68be69fc60f0","excerpt":"컴포넌트 패턴의 문제점 angular.js를 시작으로 React.js와 Vue.js의 인기가 상승하면서 컴포넌트 단위로 개발해 조립하는 방식인 Component 패턴이 현재 프론트엔드 개발의 주류가 되었다. 하지만 애플리케이션의 크기가 커지고 구조가 복잡해지면서 하나의 컴포넌트에서 다른 컴포넌트로 데이터를 전달할 때 그 사이에 있는 모든 컴포넌트들이 해당 데이터를 props로 전달해줘야하는 문제가 발생한다.  이런 문제를 Props Drilling Problem 이라고 한다. Facebook…","html":"<p><img src=\"/8cb1d8c731f6ada9d4ed8649b2e7cc6a/React.gif\"></p>\n<h1 id=\"컴포넌트-패턴의-문제점\" style=\"position:relative;\"><a href=\"#%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8-%ED%8C%A8%ED%84%B4%EC%9D%98-%EB%AC%B8%EC%A0%9C%EC%A0%90\" aria-label=\"컴포넌트 패턴의 문제점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>컴포넌트 패턴의 문제점</h1>\n<p>angular.js를 시작으로 React.js와 Vue.js의 인기가 상승하면서 컴포넌트 단위로 개발해 조립하는 방식인 Component 패턴이 현재 프론트엔드 개발의 주류가 되었다. 하지만 애플리케이션의 크기가 커지고 구조가 복잡해지면서 하나의 컴포넌트에서 다른 컴포넌트로 데이터를 전달할 때 그 사이에 있는 모든 컴포넌트들이 해당 데이터를 props로 전달해줘야하는 문제가 발생한다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 718px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 47.333333333333336%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAIAAAC9o5sfAAAACXBIWXMAAAsTAAALEwEAmpwYAAAB50lEQVQoz0XPy2sTURjG4W+SEUR3FkTqSsVFwb0I4kpEBdE/wJ0LV3UpqIuIZCUYGsFoQxS8uxKxQglq1WpL6iVNxXppTKeZZs5cnTSTpM1kZs7rmbgQzuLbPPzeQ+39aJ+Guw/OCKy90LZAJawQfhN+Ev9OWCR8IywQ5ol/If6J+BxFsxS+p5Cau9A8CGsIxjDYdqgylIFUhvvseEc71a3u2agIKWEgo1IsIyHfUUAWQScwwiqhTrGsJfkvcR9Sugsf1yuectQTrJz8Lz8M5BuBjQRYAg0JqgRFQi0Ry6Uhz33Y0guedi1wHgWVnRBTS1K8VshpCoV8JfC/pirxFZnXZCzRRnUr9CtfrWcOG4U+1jWyvepJ/nkbn6FwZlM4nYzla+oXqU9xU46b4p+iuXykzM53nAK0FEyRvW1bT1vuRFAeEVPDt4lgSjw5eCn3iwmf6hKvEaqb62y0IczarO+Mw7zKWRpmJtTHHPux1nziaumWmuEszxfPRs+p/yLpT5BPjR1ddmxdzzStTNdMQb/A9RRYCqsXRTzUss6fomFm7fql9vJlKOnox7modCCYOxxM7fbJPOF1Jjtr93vOdbj3YI/DzsO8CSMH625g3mhbOdu45emFXuMO1Fyk5nnjATcn+fyZ4C9YSnYjEvj5xgAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"그림1. Props Drilling Problem\"\n        title=\"그림1. Props Drilling Problem\"\n        src=\"/static/0bf76d402fc4902372616385c08f9607/57dc1/why-state-management-01.png\"\n        srcset=\"/static/0bf76d402fc4902372616385c08f9607/5a46d/why-state-management-01.png 300w,\n/static/0bf76d402fc4902372616385c08f9607/0a47e/why-state-management-01.png 600w,\n/static/0bf76d402fc4902372616385c08f9607/57dc1/why-state-management-01.png 718w\"\n        sizes=\"(max-width: 718px) 100vw, 718px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n    </span></p>\n<p><strong>이런 문제를 Props Drilling Problem 이라고 한다.</strong> Facebook은 이 문제 때문에 새로운 기능을 추가할 때마다 동일한 버그가 발생해서 이를 매번 고쳐야했던 비효율이 발생했다. 그런 와중에 이를 해결할 Flux라는 새로운 아키텍쳐를 개발했다.</p>\n<h1 id=\"flux-아키텍처\" style=\"position:relative;\"><a href=\"#flux-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98\" aria-label=\"flux 아키텍처 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Flux 아키텍처</h1>\n<p><strong><a href=\"https://facebook.github.io/flux/\">Flux</a>는 Facebook에서 클라이언트-사이드 애플리케이션을 만들기 위해서 사용하는 애플리케이션 아키텍처이다.</strong> 기존 MVC 패턴의 문제를 해결하기 위해 단방향 데이터 흐름(unidirectional data flow)을 활용해 React를 보완하는 역할을 한다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 638px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 75%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAAAsTAAALEwEAmpwYAAADV0lEQVQ4y12US28bVRiG89OQ2BBqe2bOmTMXz/jusWPHruPcQ6nSFrUNtpNAUCOlKiDUbsqigsKCBSCQKCyATa5tQlr+ycM343IRi0+a63ve2zkzenxCOmp0jB4doXb+QM1PaCV1onINWxkcbdDGw1Tq5GttgmqFWBXovNdk+ccNOvt9LMtg/ICZ/wNqAbS7I/rdNiUBdJTGdjRauUSNOrPVDsVGjTkvx/BWg9XDd1l4uoTnF3GN/y9gNq8BnfkxyinghXH2kfFD+SGgmpQo1DvoRotO8QrzXZ/VZ9eE5TpRUkYpjxn7/WMKd2W2jrG2jrDH57iDXW588SU3vntGe3GA73mEQZHhsMTbcZU3gzKNskO7pFj8eon+b0tUV+toWwCrH53Re/CCzsFz5g7OKN+7RPV36N3cpDfapdxsEgQhYRjR7cXkqk3y1YRK6NBtapa/X2XhlzXiXgXtCODw03O2n75k68lLbj6+oPPxK6zuBHXlLeyCIzLcLBTHURRrJXIi2TRbJH6OpfWY1V+vsfjNGn4pQmtv6qGZnJBKTz0MPrzE6YqHdh5XjNauN01ZxlRrzNbmiBsVmqZAf9Ri/fQ6Vx8vCjsf15NQ0nRTD7v3z0j2T7DGF+jeJAN0XD8Ds3XK0sUNZYG4jBH5jiQftmIat6QNV6tyL++917UJd08p7Z3iTY6wJhfCcMRwoU+nv4CVSnYNSpgaYZAyTa+1pK8cWSyvcWw3U5LVpiKh7Hz1J2sPz3nn0QuaB68odMbSuzyW7ZC3LArCzjYiWxikPmWg6TMBsnMaJaXW2YLC0N85ydh17z9n+MkZpXsvybfuEic1Bnv7tK9vEkRFfJHph9LHKMKKyjhBRNQuk3zQobaZCOv/eJh1UXqYv3OIs3NJIblNsr7C7Z9/Z+2zR1TKEYGUOyoKaBzzhtRjVkJobDQY/LRC52Ff5HtTQD0+/menuOPpTlESiuva8nMaQFHkecSlIp5rkawsc+fbH1g7eEDgudTqUbaHHfE6k6xG6T7+e+Rw2J4eDo6VwxZflASSfpx6puwCtcGAjc+fMNjdk3cKZSQ0OTjSSX2cMZNjpnOEGR9idi9w+9u4joUnPqWrumY6xgsxkqQu2NI7CSO9lvFkJ6Usw2LMX5M5rlD7tr7vAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"그림2. MVC와 Flux\"\n        title=\"그림2. MVC와 Flux\"\n        src=\"/static/cbb8272c8935f02799e7020a403d492e/41be6/why-state-management-02.png\"\n        srcset=\"/static/cbb8272c8935f02799e7020a403d492e/5a46d/why-state-management-02.png 300w,\n/static/cbb8272c8935f02799e7020a403d492e/0a47e/why-state-management-02.png 600w,\n/static/cbb8272c8935f02799e7020a403d492e/41be6/why-state-management-02.png 638w\"\n        sizes=\"(max-width: 638px) 100vw, 638px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n    </span></p>\n<h1 id=\"redux의-등장\" style=\"position:relative;\"><a href=\"#redux%EC%9D%98-%EB%93%B1%EC%9E%A5\" aria-label=\"redux의 등장 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Redux의 등장</h1>\n<p>Facebook에서 Flux 아키텍처를 발표한 후에 Flux의 구현체도 발표했는데 이는 완전한 구현체라고 부르기에는 무리가 있었다. 그래서 이 시기에는 많은 Flux 구현체들이 등장했는데 그 중에 널리 사용된 것들 중 하나가 <a href=\"https://overreacted.io/\">Dan Abramov</a>가 개발한 Redux이다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 800px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 62.66666666666667%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAANABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAAAAMCBf/EABQBAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhADEAAAAe01MskP/8QAGRABAAIDAAAAAAAAAAAAAAAAAQASAjFB/9oACAEBAAEFAlLZQ1UnSf/EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8BP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8BP//EABQQAQAAAAAAAAAAAAAAAAAAACD/2gAIAQEABj8CX//EAB0QAQABBAMBAAAAAAAAAAAAAAEAETFBURAhYaH/2gAIAQEAAT8hwnW40cJHUcChZb2Ua+z/2gAMAwEAAgADAAAAEDAP/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPxA//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPxA//8QAGhABAAMBAQEAAAAAAAAAAAAAAQARIVFBcf/aAAgBAQABPxAFkePoiwclhWnVguM8rkzcdr3kr91WKuRVaZvU/9k='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"그림3. Redux\"\n        title=\"그림3. Redux\"\n        src=\"/static/ed95fd719f60d0cbae8d339b0d4736c3/4b190/why-state-management-03.jpg\"\n        srcset=\"/static/ed95fd719f60d0cbae8d339b0d4736c3/f93b5/why-state-management-03.jpg 300w,\n/static/ed95fd719f60d0cbae8d339b0d4736c3/b4294/why-state-management-03.jpg 600w,\n/static/ed95fd719f60d0cbae8d339b0d4736c3/4b190/why-state-management-03.jpg 800w\"\n        sizes=\"(max-width: 800px) 100vw, 800px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n    </span></p>\n<p>Flux의 구현체인 Redux의 인기가 높아지면서 사실상 공식 구현체가 되었다. Redux 덕분에 규모가 큰 애플리케이션 내에서 컴포넌트들사이에서 데이터를 전달할 때 발생하는 문제점과 비효율을 하나의 중앙 저장소와 단방향 데이터 흐름의 구조를 통해 처리함으로 해결할 수 있게 되었다. <strong>하지만 Redux가 Flux와 완전히 동일한 것은 아니다.</strong></p>\n<h1 id=\"flux와-redux의-차이\" style=\"position:relative;\"><a href=\"#flux%EC%99%80-redux%EC%9D%98-%EC%B0%A8%EC%9D%B4\" aria-label=\"flux와 redux의 차이 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Flux와 Redux의 차이</h1>\n<p>Flux가 <code class=\"language-text\">여러 개의 Store</code>와 <code class=\"language-text\">dispatcher</code>라는 개념을 가지고 있는 반면에 Redux는 <code class=\"language-text\">dispatcher</code>라는 개념이 따로 존재하지 않고 <code class=\"language-text\">오직 하나의 Store</code>를 가지며 불변한 상태를 기반으로 동작한다.</p>\n<p>이런 Redux만의 특징은 Flux의 장점은 그대로 차용하면서 쉽게 사용가능하고 예측 가능한 애플리케이션을 개발할 수 있도록 도와준다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 770px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 55.333333333333336%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAALABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAAAQADBf/EABQBAQAAAAAAAAAAAAAAAAAAAAH/2gAMAwEAAhADEAAAAewaoEy//8QAGBABAQEBAQAAAAAAAAAAAAAAAQIRIhL/2gAIAQEAAQUC3pvmHZ8m1JRISf/EABURAQEAAAAAAAAAAAAAAAAAAAEQ/9oACAEDAQE/ASf/xAAVEQEBAAAAAAAAAAAAAAAAAAABEP/aAAgBAgEBPwEn/8QAGhAAAwADAQAAAAAAAAAAAAAAAAEREiExQv/aAAgBAQAGPwKZIfk7SmyI/8QAGhABAQEBAAMAAAAAAAAAAAAAAREAITFBcf/aAAgBAQABPyFfuL4jmUThgt7gJPpl+XdAGmiCG//aAAwDAQACAAMAAAAQC+//xAAWEQEBAQAAAAAAAAAAAAAAAAABECH/2gAIAQMBAT8QCOz/xAAWEQADAAAAAAAAAAAAAAAAAAAAASH/2gAIAQIBAT8Qh0Z//8QAGxABAQEAAwEBAAAAAAAAAAAAAREAITFBcYH/2gAIAQEAAT8QOgKgX4ZR3lUvhhOeEWL73q33ja97i0GypzhMQrLd/9k='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"그림3. Flux와 Redux의 차이\"\n        title=\"그림3. Flux와 Redux의 차이\"\n        src=\"/static/53c5e54b674ebeaaf995b996ca40e925/e6e7b/why-state-management-04.jpg\"\n        srcset=\"/static/53c5e54b674ebeaaf995b996ca40e925/f93b5/why-state-management-04.jpg 300w,\n/static/53c5e54b674ebeaaf995b996ca40e925/b4294/why-state-management-04.jpg 600w,\n/static/53c5e54b674ebeaaf995b996ca40e925/e6e7b/why-state-management-04.jpg 770w\"\n        sizes=\"(max-width: 770px) 100vw, 770px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n    </span></p>\n<br/>","frontmatter":{"title":"상태 관리가 필요한 이유","date":"December 22, 2021"}}},"pageContext":{"slug":"/React/why-state-management/","previous":{"fields":{"slug":"/JavaScript/closure/"},"frontmatter":{"title":"[JS] 클로저"}},"next":{"fields":{"slug":"/Error/unknown-cask/"},"frontmatter":{"title":"Error: Unknown command: cask"}}}},"staticQueryHashes":["2486386679","3128451518"]}