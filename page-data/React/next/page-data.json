{"componentChunkName":"component---src-templates-blog-post-js","path":"/React/next/","result":{"data":{"site":{"siteMetadata":{"title":"leo-xee.io","author":"Leo-Xee","siteUrl":"https://leo-xee.github.io","comment":{"disqusShortName":"","utterances":"leo-xee/blog-comments"},"sponsor":{"buyMeACoffeeId":"leoxexe"}}},"markdownRemark":{"id":"0213c3d4-6fc0-50ff-88ec-5cd98e6d0501","excerpt":"Next.js란? Next.js는 SSR(Server Side Rendering)을 쉽게 구현할 수 있는 개발 환경을 제공하는 React의 프레임워크이다. 물론 React도 SSR을 고려해서 설계되었기 때문에 React만으로 SSR을 구현할 수도 있지만 이를 위해서 설정하는 과정이 꽤나 복잡하다고 한다. 이외에도 다양한 이유로 현재 Next.js가 많이 사용되는 추세이다. Next.js의 등장 배경 과거의 대부분 웹사이트들은 SSR과 MPA(Multi Page Application…","html":"<p><img src=\"/81aefd7d1672183644b6579d60eee69e/Next.gif\"></p>\n<h1 id=\"nextjs란\" style=\"position:relative;\"><a href=\"#nextjs%EB%9E%80\" aria-label=\"nextjs란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Next.js란?</h1>\n<p><strong>Next.js는 SSR(Server Side Rendering)을 쉽게 구현할 수 있는 개발 환경을 제공하는 React의 프레임워크이다.</strong> 물론 React도 SSR을 고려해서 설계되었기 때문에 React만으로 SSR을 구현할 수도 있지만 이를 위해서 설정하는 과정이 꽤나 복잡하다고 한다. 이외에도 다양한 이유로 현재 Next.js가 많이 사용되는 추세이다.</p>\n<h1 id=\"nextjs의-등장-배경\" style=\"position:relative;\"><a href=\"#nextjs%EC%9D%98-%EB%93%B1%EC%9E%A5-%EB%B0%B0%EA%B2%BD\" aria-label=\"nextjs의 등장 배경 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Next.js의 등장 배경</h1>\n<p><strong>과거의 대부분 웹사이트들은 SSR과 MPA(Multi Page Application) 방식으로 동작해왔었다.</strong> 하지만 우리 기억에도 남아있는 페이지 이동 시에 깜빡거리는 현상과 같은 문제들로 인해 사용자 경험이 좋지 못했고 동시에 스마트폰의 시대가 도래하면서 앱과 같은 사용성의 수요가 커져갔다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 1200px;\"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 56.333333333333336%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAALABQDASIAAhEBAxEB/8QAGAAAAgMAAAAAAAAAAAAAAAAAAAUBAwT/xAAVAQEBAAAAAAAAAAAAAAAAAAABAv/aAAwDAQACEAMQAAABXsWWhmCwK//EABoQAQACAwEAAAAAAAAAAAAAAAIAAwEEEhH/2gAIAQEAAQUCEGr0hWCdasmrkzGPJ//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8BP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8BP//EAB0QAAICAQUAAAAAAAAAAAAAAAABAhESECEjMWH/2gAIAQEABj8CrDJnJUPEVGKoi0t2daf/xAAbEAEAAwADAQAAAAAAAAAAAAABABEhQVFxgf/aAAgBAQABPyFF4p7CBod2/ZREELOBrzFoAUT/2gAMAwEAAgADAAAAECwP/8QAFhEBAQEAAAAAAAAAAAAAAAAAAAER/9oACAEDAQE/EMqP/8QAFhEAAwAAAAAAAAAAAAAAAAAAARAR/9oACAECAQE/EKF//8QAHRABAAIBBQEAAAAAAAAAAAAAAQARYSExQXGBUf/aAAgBAQABPxBYKGgtPgTu1GXZWoC+SAdcvLAh/d9esUVKrbllRaLup//Z'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"그림1. AJAX와 jQuery의 등장\"\n        title=\"그림1. AJAX와 jQuery의 등장\"\n        src=\"/static/714cc668e5fa205c53aba2b167bc61b4/e5166/next-01.jpg\"\n        srcset=\"/static/714cc668e5fa205c53aba2b167bc61b4/f93b5/next-01.jpg 300w,\n/static/714cc668e5fa205c53aba2b167bc61b4/b4294/next-01.jpg 600w,\n/static/714cc668e5fa205c53aba2b167bc61b4/e5166/next-01.jpg 1200w\"\n        sizes=\"(max-width: 1200px) 100vw, 1200px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n    </span></p>\n<p><strong>이런 시기에 AJAX와 jQuery가 등장했고 커뮤니티에서도 많이 사용되면서 클라이언트에서 비동기적으로 JSON 형태의 데이터만을 서버에 요청하고 받아와서 사용자에게 데이터와 함께 웹 페이지를 보여주는 방식이 대세가 되었다.</strong></p>\n<p>하지만 여기서 더 나아가서 클라이언트에서 데이터를 받아오는 것뿐만 아니라 웹페이지도 렌더링해버리자는 요구도 생겨났다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 1200px;\"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 55.666666666666664%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAALABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAAAAIDBf/EABQBAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhADEAAAAeXeApI//8QAGRABAAIDAAAAAAAAAAAAAAAAAQIQESEi/9oACAEBAAEFAscsAXTf/8QAFhEAAwAAAAAAAAAAAAAAAAAAARAx/9oACAEDAQE/ARF//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPwE//8QAGRAAAQUAAAAAAAAAAAAAAAAAEQABICIx/9oACAEBAAY/AiU1tj//xAAZEAEBAAMBAAAAAAAAAAAAAAABEQAgQVH/2gAIAQEAAT8hn2YEwxzjhEBs0//aAAwDAQACAAMAAAAQMM//xAAXEQEBAQEAAAAAAAAAAAAAAAABACGh/9oACAEDAQE/EMIdXkX/xAAVEQEBAAAAAAAAAAAAAAAAAAABEP/aAAgBAgEBPxBn/8QAHBAAAgICAwAAAAAAAAAAAAAAAREAISBBUXGh/9oACAEBAAE/EB4pBlu7ToMWWUfJ3h//2Q=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"그림2. SPA 3대장의 등장\"\n        title=\"그림2. SPA 3대장의 등장\"\n        src=\"/static/b76cdb70a5262eda77283e61c47e6843/e5166/next-02.jpg\"\n        srcset=\"/static/b76cdb70a5262eda77283e61c47e6843/f93b5/next-02.jpg 300w,\n/static/b76cdb70a5262eda77283e61c47e6843/b4294/next-02.jpg 600w,\n/static/b76cdb70a5262eda77283e61c47e6843/e5166/next-02.jpg 1200w,\n/static/b76cdb70a5262eda77283e61c47e6843/c8ae0/next-02.jpg 1279w\"\n        sizes=\"(max-width: 1200px) 100vw, 1200px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n    </span></p>\n<p><strong>이런 요구에 응하면서 등장한 것이 흔히 SPA 3대장이라고 일컫는 React, Angular, Vue와 같은 라이브러리 및 프레임워크이다.</strong></p>\n<p>이들로 인해 최근까지 CSR(Client Side Rendering)이 가능한 SPA(Single Page Application)의 전성기가 이어져왔다.</p>\n<p>하지만 욕심은 끝이 없는 법!!! 😈</p>\n<p>이런 CSR + SPA 방식에서도 몇 가지 문제가 발생하기 시작하는데 다음과 같다.</p>\n<ul>\n<li>초기 로딩이 느리다.</li>\n<li>페이지 캐싱이 잘 안된다.</li>\n<li>SEO(Search Engine Optimization)이 잘 안된다.</li>\n</ul>\n<p>지금까지의 과정 속에서 누적되어왔던 문제를 해결하기 위해서 CSR과 SSR의 장점만을 모은 <strong>Vercel의 Next.js가 등장하게 되었다.</strong></p>\n<h1 id=\"nextjs의-장점\" style=\"position:relative;\"><a href=\"#nextjs%EC%9D%98-%EC%9E%A5%EC%A0%90\" aria-label=\"nextjs의 장점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Next.js의 장점</h1>\n<p>Next.js의 장점은 다양하지만 크게 3가지를 정리해본다.</p>\n<h2 id=\"built-in-routing-system\" style=\"position:relative;\"><a href=\"#built-in-routing-system\" aria-label=\"built in routing system permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Built-in Routing System</h2>\n<p>Next.js 는 Page 기반의 라우팅 시스템을 기본적으로 제공한다.</p>\n<p>Next.js에서 페이지 라우팅을 구현하기 위해서는 프로젝트 루트 위치에 <code class=\"language-text\">pages</code> 라는 디렉토리를 생성하고 내부에 라우팅될 파일을 작성하면 해당 파일명과 매핑되어서 알아서 라우팅된다. 이는 기존 React에서 <code class=\"language-text\">react-router-dom</code> 라이브러리를 따로 설치하고 따로 구현해야만했던 개발자의 수고를 덜어준다.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">pages\n ├── about.jsx\n ├── index.jsx\n ├── profile.jsx\n └── signup.jsx</code></pre></div>\n<h2 id=\"code-splitting\" style=\"position:relative;\"><a href=\"#code-splitting\" aria-label=\"code splitting permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Code Splitting</h2>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token builtin class-name\">.</span>\n├── .next              <span class=\"token comment\"># 빌드파일</span>\n├── components         <span class=\"token comment\"># React 컴포넌트 디렉토리</span>\n│\t  ├── Header.jsx\n│\t\t└── Footer.jsx\n├── node_modules\n├── next.config.js     <span class=\"token comment\"># Next.js 설정 파일</span>\n├── package-lock.json\n├── package.json\n├── pages              <span class=\"token comment\"># pages 내부의 각 파일이 URL과 파일명으로 매핑되어 라우팅된다.</span>\n│\t  ├── _app.jsx       <span class=\"token comment\"># 서버에서 요청 시에 가장 먼저 실행되는 컴포넌트, 페이지에 적용할 공통 레이아웃을 여기서 적용한다.</span>\n│\t  ├── _document.jsx  <span class=\"token comment\"># _app.jsx 다음으로 실행되며 공통적으로 사용할 &lt;Head>, &lt;body>등과 같은 태그들을 커스텀할 때 사용한다.</span>\n│\t  ├── _error.js      <span class=\"token comment\"># error가 발생했을 때 처리하는 페이지</span>\n│\t  ├── about.jsx\n│\t  ├── index.jsx\n│\t  ├── profile.jsx\n│\t\t└── signup.jsx\n├── static             <span class=\"token comment\"># 이미지와 같은 리소스를 저장하는 디렉토리</span>\n├── redux\n├── yarn-error.log\n└── yarn.lock</code></pre></div>\n<h2 id=\"server-side-rendering\" style=\"position:relative;\"><a href=\"#server-side-rendering\" aria-label=\"server side rendering permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Server Side Rendering</h2>\n<p>Next.js는 SSR, SSG를 지원하고 다양한 옵션을 제공한다.</p>\n<p><code class=\"language-text\">getStaticProps</code>, <code class=\"language-text\">getStaticPaths</code>, <code class=\"language-text\">getServerSideProps</code>등과 같은 API를 개발자에게 제공함으로써 특정 페이지를 그냥 CSR로 처리할지, SSR로 처리할지 또는 서버에 HTML을 미리 만들어두거나 <code class=\"language-text\">Pre-Rendering</code> 할 것인지… 등의 다양한 옵션을 해당 페이지의 특성에 맞게 개발자가 개발할 수 있도록 도와준다.</p>\n<p>이 외에도 이미지, 폰트 최적화등 다양한 기능들을 제공한다.</p>\n<br>","frontmatter":{"title":"Next.js","date":"January 10, 2022"}}},"pageContext":{"slug":"/React/next/","previous":{"fields":{"slug":"/Web/csr-ssr/"},"frontmatter":{"title":"CSR vs SSR"}},"next":{"fields":{"slug":"/CS/charset-encoding/"},"frontmatter":{"title":"문자셋과 인코딩"}}}}}